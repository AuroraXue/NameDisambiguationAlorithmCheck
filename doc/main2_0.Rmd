---
title: "Project 4 - Example Main Script"
author: "Jing Wu, Tian Zheng"
date: "3/22/2017"
output: pdf_document
---

This file is currently a template for implementing one of the suggested papers, Han, Zha, & Giles (2005). Due to the nature of the method, we only implement the method on a subset of the data, "AKumar.txt". In your project, you need to work on the whole dataset. You should follow the same structure as in this tutorial, but update it according to the papers you are assigned.

## Step 0: Load the packages, specify directories

```{r}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(text2vec, dplyr, qlcMatrix, kernlab, knitr)

setwd("~/Spr2017-proj4-team10-master/doc")
# here replace it with your own path or manually set it in RStudio
# to where this rmd file is located
```

## Step 1: Load and process the data

For each record in the dataset, there are some information we want to extract and store them in a regular form: canonical author id, coauthors, paper title, publication venue title. You may need to find regular matched in the input string vectors by using regex in R. Here is a tutorial for regular expression in R, which might help you <https://rstudio-pubs-static.s3.amazonaws.com/74603_76cd14d5983f47408fdf0b323550b846.html>

```{r}
# scan & make it a data frame
AKumar <- data.frame(scan("~/Spr2017-proj4-team10-master/data/nameset/AKumar.txt",
                          what = list(Coauthor = "", Paper = "", Journal = ""),
                          sep=">", quiet=TRUE),stringsAsFactors=FALSE)


# This need to be modified for different name set

# extract canonical author id befor "_"
AKumar$AuthorID <- sub("_.*","",AKumar$Coauthor)

# extract paper number under same author between "_" and first whitespace
AKumar$PaperNO <- sub(".*_(\\w*)\\s.*", "\\1", AKumar$Coauthor)

# delete "<" in AKumar$Coauthor, you may need to further process the coauthor
# term depending on the method you are using
#AKumar$Coauthor <- gsub("<","",sub("^.*?\\s","",AKumar$Coauthor))

AKumar$Coauthor <- gsub("<","",sub("^.*?\\s","",AKumar$Coauthor))
# delete "<" in AKumar$Paper
AKumar$Paper <- gsub("<","",AKumar$Paper)
# add PaperID for furthur use, you may want to combine all the nameset files and 
# then assign the unique ID for all the citations
AKumar$PaperID <- rownames(AKumar)
```

## Step 2: Feature design

Following the section 3.1 in the paper, we want to use paper titles to design features for citations. As the notation used in the paper, we want to find a $m$-dimensional citation vector $\alpha_i$ for each citation $i$, $i=1,...,n$. In this dataset, $n=$ `r nrow(AKumar)`. We study "TF-IDF" (term frequency-inverse document frequency) as suggested in the paper.

TF-IDF is a numerical statistics that is intended to reflect how important a word is to a document in a collection or corpus. It is often used as a weighting factor in information retrieval, text mining, and user modeling. The TF-IDF value increases proportionally to the number of times a word appears in the document, but is offset by the frequency of the word in the corpus, which helps to adjust for the fact that some words appear more frequently in general.

$$
\begin{aligned}
\mbox{TF}(t) &=\frac{\mbox{Number of times term $t$ appears in a document}}{\mbox{Total number of terms in the document}}\\
\mbox{IDF}(t) &=\log{\frac{\mbox{Total number of documents}}{\mbox{Number of documents with term $t$ in it}}}\\
\mbox{TF-IDF}(t) &=\mbox{TF}(t)\times\mbox{IDF}(t)
\end{aligned}
$$

To compute TF-IDF, we first need to construct a document-term matrix (DTM). In other words, the first step is to vectorize text by creating a map from words to a vector space. There are some good packages you could use for text mining (probably you have tried during first project, you don't need to follow my code if you are familiar with other package), e.g. *text2vec, tm, tidytext*. Here, we are going to use *text2vec* package. A good tutorial can be found here, <https://cran.r-project.org/web/packages/text2vec/vignettes/text-vectorization.html>.

Let’s first create a vocabulary-based DTM. Here we collect unique terms from all documents and mark each of them with a unique ID using the  `create_vocabulary()` function. We use an iterator to create the vocabulary.
```{r}
it_train <- itoken(AKumar$Coauthor, 
             preprocessor = tolower, 
             tokenizer = word_tokenizer,
             ids = AKumar$PaperID,
             # turn off progressbar because it won't look nice in rmd
             progressbar = FALSE)
vocab <- create_vocabulary(it_train, stopwords = c("a", "an", "the", "in", "on",
                                                   "at", "of", "above", "under"))

vocab
```

Here, we remove pre-defined stopwords, the words like “a”, “the”, “in”, “I”, “you”, “on”, etc, which do not provide much useful information. 

Now that we have a vocabulary list, we can construct a document-term matrix.
```{r}
vectorizer <- vocab_vectorizer(vocab)
dtm_train <- create_dtm(it_train, vectorizer)
```

Now we have DTM and can check its dimensions.
```{r}
dim(dtm_train)
```

As you can see, the DTM has `r nrow(dtm_train)` rows, equal to the number of citations, and `r ncol(dtm_train)`, equal to the number of unique terms excluding stopwords.

Then, we want to use DTM to compute TF-IDF transformation on DTM.
```{r}
tfidf <- TfIdf$new()
dtm_train_tfidf <- fit_transform(dtm_train, tfidf)
```

```{r}
### load other dataset 
```

## Step 3: Clustering

## method 1:spectral clustering

Following suggestion in the paper, we carry out spectral clustering on the Gram matrix of the citation vectors by using R function `specc()` in *kernlab*. The number of clusters is assumed known as stated in the paper.
```{r}
start.time <- Sys.time()
result_sclust <- specc(as.matrix(dtm_train_tfidf), 
                       centers=length(unique(JMartin$AuthorID)))
end.time <- Sys.time()
time_sclust <- end.time - start.time
table(result_sclust)
```

We can also using hierarchical clustering method under the cosine distance. The intention of using a different clustering method is just to let you know how to compare performance between various methods. 
```{r}
start.time <- Sys.time()
docsdissim <- cosSparse(t(dtm_train_tfidf))
rownames(docsdissim) <- c(1:nrow(dtm_train_tfidf))
colnames(docsdissim) <- c(1:nrow(dtm_train_tfidf))
#compute pairwise cosine similarities using cosSparse function in package qlcMatrix
h <- hclust(as.dist(docsdissim), method = "ward.D")
result_hclust <- cutree(h,length(unique(AKumar$AuthorID)))
end.time <- Sys.time()
time_hclust <- end.time - start.time
table(result_hclust)
```


## method 2: em algorithm

Based on the unified probabilistic model using Hidden Markov Random Fields (HMRF) in paper 6, we used the model incorporating c6 constraint and a parameterized-distance measure to do the clustering through EM algorithm. 


C6 constraint is one of the constraints defined between two papers pi and pj...

#### remember here is a parameter τ ####
#### introduce the constrain matrix construction here ####
...using the function `M_prod()` defined in `customized_function.R`... 



After calculating the C6 constraint matrix,we followed the EM process to update labels for every paper to minimize the objective function in each iteration until the clusters stop changing.


For initialization of our EM framework, we first cluster publications into disjoint groups based on the constraints over them. Then,we calculate the current number of clusters as lambda and re-adjust the labels of some papers to make the lambda equal to the actual author number.


```{r}
## initialize
source("../lib/customized_function.R")
source("../lib/em_test5.R")
load("../output/paper_tfidf.Rdata")
load("../output/journal_tfidf.Rdata")
load("../output/text.Rdata")
dtm<-cbind(tfidf_paper$AKumar.Rdata,tfidf_journal$AKumar.Rdata)   ### change the name here
truth<-Data[[2]]$AuthorID  ### change the number here
k <- length(unique(truth))


#dtm<-dtm_train_tfidf
n<-nrow(dtm)
#truth<-AKumar$AuthorID
#k <- length(unique(AKumar$AuthorID)) 
M_p<-M_prod(2,tao=1,n)   ### change the number here
tag<-ini(M_p)
tag_ini<-tag
```

Before getting into the EM framework, we define two kinds of distance function.

First,distance function $D(x_i,x_j)$.It's used to measure the distance between two papers as the following,A is a parameter matrix(initialized as a diagonal matrix).

$$ D(x_i,x_j) = 1-\frac{x_i^TAx_j}{||x_i||_A||x_j||_A},||x_i||_A = \sqrt{x_i^TAx_j}$$
Second,distance function $D(x_i,y_{l_i})$,$l_i$ is the tag for $x_i$.It's used to measure the distance between a paper and author $y_{l_i}$(represented by a set of assigned papers).Actually, we count this distance in this way, for a certain paper $x_i$,we find the papers with the same current labels with $x_i$, calculate the distance between the paper $x_i$ and one of these papers respectively,get an average as $D(x_i,y_{l_i})$. 

In the E-step,to update a certain paper $x_i$'s label,we changing different label for $x_i$ and try to minimize our objective function as the following.

$$ f(y_h,x_i) = D(x_i,y_h) + \sum_{i,j \neq i}D(x_i,x_j)*w*c_6 $$

The objective function contains two parts:

The first part is to minimize the distance between paper $x_i$ and its current label, the second part wants to minimize the sum of the distances between $x_i$ and a certain type of papers,whose labels is different from $x_i$ but have a constrain with $x_i$.


We sequentially update the assignment of each paper until all papers' assignment updated. 

$$ f(y_h,x_i) = D(x_i,y_h) + $$

In the M-step, we update each cluster's center as the following way: 

$$ y_h = \frac{\sum_{i:l_i = h}x_i}{||\sum_{i:l_i = h}x_i||_A} $$

Then, each parameter amm in A is updated by (only parameters on
the diagonal):

$$ a_{mm} = a_{mm} + \eta \frac{\partial f_{obj} }{\partial a_{mm}}$$

```{r}
start.time <- Sys.time()
## em initialization
size<-0.01
c<-M_p
n<-nrow(dtm)  ## number of papers 244
m<-ncol(dtm)  ## 666
A<-rep(1,m)  ## 666 * 666
eta <- -0.0001 ## need tune later
distance<-rep(10000,length(unique(tag)))
D_xx<-matrix(ncol=n,nrow=n)  ## 244 * 244
D_xx_deriv<-array(NA,c(n,n,m))  ## 244 * 244 * 666

## em
iter<-1
while(sum(distance) > size)
  {
    ##### count D_xx
    A.ind<-ifelse(A>0,1,0)
    sqrtA<-A.ind*sqrt(abs(A))
    A.mat <- diag(sqrtA,m,m)
    part<-cosSparse(t(dtm %*% A.mat))
    D_xx<- 1 - part
    
    ##### update researcher representative(cluster centers)
    
    uni.tag<-unique(tag) 
    if (exists("y_h_former")){
      y_h_former<-y_h}else{
        y_h_former<-matrix(0,length(uni.tag),ncol(dtm))}
    df<-data.frame(as.matrix(dtm),tag)
    y_h<-aggregate(df,by=list(tag),mean)[,1:m]
    
    
    
    ##### adjust for x_i's tag
    
    for (i in 1:n)  
    {
      ## input : initialized cluster(tag)
      
      f.xi<-rep(NA,length(uni.tag))  ## f for trying x_i's all tags.
      j=1
      for (k in uni.tag)   ## substitute x_i's tag by tag "k"
      {
        newtag <- tag
        newtag[i]<-k
        f.xi[j]<-f(tagvec=newtag,paperindex=i,n0=n)   
        #f.xi[j] <- distance.xy(paper_index=i,tag.vec=newtag)
        j<-j+1
      }
      tag[i]<-uni.tag[which.min(f.xi)]
    }
    
    
    
    ##### update a_mm
    
    #count ||x_i||_A
    
    part0<-rep(NA,n)
    A.ind<-ifelse(A>0,1,0)
    sqrtA<-A.ind*sqrt(abs(A))
    A.mat <- diag(sqrtA,m,m)
    ax <- dtm %*% A.mat # 244 * 666
    for (i in 1:dim(ax)[1])
    {
      part0[i] <- dist(rbind(ax[i,],rep(0,m)), method = "euclidean")
    }
    
    for (i in 1:n){
      for (j in i:n){
        part1<-rep(NA,m)
        part1<- dtm[i,]^2 * part0[j]^2 + dtm[j,]^2 * part0[i]^2
        D_xx_deriv[i,j,]<- dtm[i,]*dtm[j,]*(part0[i]* part0[j])- part1 * part[i,j]/2
        D_xx_deriv[i,j,]<-D_xx_deriv[i,j,] / (part0[i]^2 * part0[j]^2)
        D_xx_deriv[j,i,]<-D_xx_deriv[i,j,]
      }}

  
    for (mm in 1:m)
    {
      uni.tag<-unique(tag)
      indicate<- 1- class.ind(tag) %*% t(class.ind(tag))
      deriv.f<- sum( D_xx_deriv[,,mm] * M_p * indicate )
      A[mm] <- A[mm] + eta * deriv.f
    }
    
    ##### stop-iteration condition 
    
    
    ord.y_h<-y_h[order(y_h[,1]),]
    ord.y_h_former<-y_h_former[order(y_h_former[,1]),]
    
    for (i in 1:nrow(ord.y_h))
    {
      distance[i]<-dist(rbind(ord.y_h[i,],ord.y_h_former[i,]), method= "euclidian")
    }
    
    #print(iter)
    #iter<-iter+1
    source('../lib/evaluation_measures.R')
    #truth<-AKumar$AuthorID
    #truth<-AKumar$AuthorID[1:10]


    ## result for initialization 
    #matching_matrix_p6 <- matching_matrix(truth,tag_ini)
    #performance_p6 <- performance_statistics(matching_matrix_p6)
    #print(performance_p6)

    ## result for em
    matching_matrix_p6 <- matching_matrix(truth,tag)
    performance_p6 <- performance_statistics(matching_matrix_p6)
    print(performance_p6)
   
}

result_em<-tag
end.time <- Sys.time()
time_em <- end.time - start.time

## time spent
time_em

## row number of current data
n
```

## Step 4: Evaluation

To evaluate the performance of the method, it is required to calculate the degree of agreement between a set of system-output partitions and a set of true partitions. In general, the agreement between two partitioins is measured for a pair of entities within partitions. The basic unit for which pair-wise agreement is assessed is a pair of entities (authors in our case) which belongs to one of the four cells in the following table (Kang et at.(2009)):

\includegraphics[width=500pt]{matching_matrix.png}

Let $M$ be the set of machine-generated clusters, and $G$ the set of gold standard clusters. Then. in the table, for example, $a$ is the number of pairs of entities that are assigned to the same cluster in each of $M$ and $G$. Hence, $a$ and $d$ are interpreted as agreements, and $b$ and $c$ disagreements. When the table is considered as a confusion matrix for a two-class prediction problem, the standard "Precision", "Recall","F1", and "Accuracy" are defined as follows.

$$
\begin{aligned}
\mbox{Precision} &=\frac{a}{a+b}\\
\mbox{Recall}&=\frac{a}{a+c}\\
\mbox{F1} &=\frac{2\times\mbox{Precision}\times\mbox{Recall}}{\mbox{Precision}+\mbox{Recall}}\\
\mbox{Accuracy}&=\frac{a+d}{a+b+c+d}
\end{aligned}
$$


## method 1

```{r}
source('../lib/evaluation_measures.R')
matching_matrix_hclust <- matching_matrix(JMartin$AuthorID,result_hclust)
performance_hclust <- performance_statistics(matching_matrix_hclust)
matching_matrix_sclust <- matching_matrix(JMartin$AuthorID,result_sclust)
performance_sclust <- performance_statistics(matching_matrix_sclust)
compare_df <- data.frame(method=c("sClust","hClust"),
                         precision=c(performance_sclust$precision, performance_hclust$precision),
                         recall=c(performance_sclust$recall, performance_hclust$recall),
                         f1=c(performance_sclust$f1, performance_hclust$f1),
                         accuracy=c(performance_sclust$accuracy, performance_hclust$accuracy),
                         time=c(time_sclust,time_hclust))
kable(compare_df,caption="Comparision of performance for two clustering methods",digits = 2)
```


## method 2

```{r}
source('../lib/evaluation_measures.R')
#truth<-AKumar$AuthorID
#truth<-AKumar$AuthorID[1:10]


## result for initialization 
matching_matrix_p6 <- matching_matrix(truth,tag_ini)
performance_p6 <- performance_statistics(matching_matrix_p6)
performance_p6

## result for em
result_em<-tag
matching_matrix_p6 <- matching_matrix(truth,result_em)
performance_p6 <- performance_statistics(matching_matrix_p6)
performance_p6
```


